# SE_Refactoring

# گزارش آزمایش:

بازآرایی Facade - مورد اول:
از CodeGenerator در Parser مستقیما استفاده می‌شود و برای کاهش این پیچیدگی، کلاسی با نام CodeGeneratorFacade  اضافه می‌کنیم که توابع مورداستفاده کلاینت را در آن پیاده‌سازی می‌شوند. سپس در این توابع، توابع خود CodeGenerator صدا زده می‌شوند.

<img width="542" alt="1" src="https://github.com/epMahdiyeh/SE_Refactoring/assets/62205305/46c102a3-db47-4feb-8b5c-f937d26250f8">

[CodeGenerator Facade](https://github.com/epMahdiyeh/SE_Refactoring/commit/e12be4107be9681fe14709f72b6ec54e3930921a)

بازآرایی Facade - مورد دوم:

مشابه مورد اول، در این بازآرایی نیز کلاسی به نام MemoryFacade طراحی می‌کنیم که در آن SymbolTable مستقیما از Memory استفاده نکند و واسطی داشته باشد.

<img width="532" alt="2" src="https://github.com/epMahdiyeh/SE_Refactoring/assets/62205305/7a0b25a2-5e70-4d69-85bd-1acb9596d0d9">

[Memory Facade](https://github.com/epMahdiyeh/SE_Refactoring/commit/11a4aadc9e2ec88bf59cfa737bcb996f1644d28a)


بازآرایی استفاده از Polymorphism به جای شرط:

در این بازآرایی، به جای استفاده از ساختار switch-case، هر مورد را به یک کلاس جدید متناظر با همان case تبدیل می‌کنیم. برای این کار، enum طراحی شده مربوط به TypeAddress را به interface تبدیل کرده و تغییرات لازم را بصورت زیر اجرا می‌کنیم:

<img width="654" alt="3" src="https://github.com/epMahdiyeh/SE_Refactoring/assets/62205305/a1fa012a-9ad4-47f2-b0f6-3d3f06a5c7f0">

پیاده‌سازی کلاس DirectAddress:

<img width="394" alt="4" src="https://github.com/epMahdiyeh/SE_Refactoring/assets/62205305/a477777e-204c-4fb1-839a-be5ec626401f">

پیاده‌سازی کلاس ImidiateAddress:

<img width="378" alt="5" src="https://github.com/epMahdiyeh/SE_Refactoring/assets/62205305/34ee9117-5b89-4a0f-9447-f0ece2b7823b">

پیاده‌سازی کلاس IndirectAddress:

<img width="394" alt="6" src="https://github.com/epMahdiyeh/SE_Refactoring/assets/62205305/a0d08611-31c4-4655-9a9f-b322f28efff8">

[Polymorphism](https://github.com/epMahdiyeh/SE_Refactoring/commit/68e5feed892f085022a07c9e27a845f05a0a7b49)


بازآرایی Separate Query from Modifier:

این بازآرایی به اصل CQRS می‌پردازد که مربوط به جداسازی دستورات و کوئری‌ها و وظایف مربوط به آن‌هاست. تفکیک این دستورات و کوئری‌ها به این معنی است که هر کدام می‌توانند در صورت نیاز بهینه شوند. درواقع کدهایی که داده‌ها را دریافت می‌کنند از کدهایی که تغییراتی را در یک Object ایجاد می‌کنند جدا می‌کنیم. در اینجا مقدار بازگشتی تابع getNextParameter را به شرح زیر تغییر میدهیم:

<img width="666" alt="7" src="https://github.com/epMahdiyeh/SE_Refactoring/assets/62205305/110e4c39-66e3-45fc-87fb-91d0c6a6c3d5">

[Separate Query from Modifier](https://github.com/epMahdiyeh/SE_Refactoring/commit/d75c8c4e4132ab391d98912d2f2f3c2bf89f12b5)


بازآرایی Self Encapsulate Field:

در توابع یک کلاس، ممکن است مستقیما از متغیرهای خصوصی موجود در کلاس استفاده شود. گاهی اوقات این دسترسی مستقیم در کلاس انعطاف‌پذیری کافی را برای توسعه بهتر فراهم نمی‌کند. برای مثال در این پروژه lexicalAnalyzer دسترسی مستقیم به متغیر خصوصی matcher وجود دارد که به منظور تغییر این شرایط، متدهای setMatcher و getMatcher را طراحی می‌کنیم تا بجای استفاده مستقیم از matcher بتوانیم از این متدها استفاده کنیم:

<img width="903" alt="8" src="https://github.com/epMahdiyeh/SE_Refactoring/assets/62205305/bb3157a7-398b-436e-98af-26051af20395">

[Self Encapsulate Field](https://github.com/epMahdiyeh/SE_Refactoring/commit/4347a02ae04f1e174314bb62f147a9a94d048375)


بازآرایی Inline Temp:

زمانی که متغیری داشته باشیم که صرفا حاصل یک expression به آن اختصاص داده می‌شود و کارایی دیگری برای متغیر وجود ندارد، می‌توانیم ارجاعات آن متغیر را با خود expression جایگزین کنیم. این مورد در Token و تابع hashCode دیده می‌شود که می‌توان آن را به شکل زیر تغییر داد:

<img width="895" alt="9" src="https://github.com/epMahdiyeh/SE_Refactoring/assets/62205305/45df8711-4963-4652-84a7-7b45b36afd70">

[Inline Temp](https://github.com/epMahdiyeh/SE_Refactoring/commit/381cf51a072c2828d7f57af9d8a77ef6827b7a2b)

بازآرایی Extract Variable:

در این بازآرایی یک متغیر جدید تعریف میکنیم به این منظور که بتوانیم از مقدار آن به جای دسترسی به مقدار برخی توابع استفاده کنیم. این کار به خوانایی کد کمک می‌کند و اگر در آینده نیاز به ایجاد تغییر در این مقدار داشته باشیم، کافیست فقط مقدار متغیر را تغییر دهیم. یک نمونه از این تغییر در کلاس CodeGenerator به صورت زیر مشخص است:

<img width="888" alt="12" src="https://github.com/epMahdiyeh/SE_Refactoring/assets/62205305/0dcbfcd7-e311-4306-a969-4b786ea6fc56">

[Extract Variable](https://github.com/epMahdiyeh/SE_Refactoring/commit/9cbcc91f8c243c28ec1df2cf7c8822ded1b88d9c)

------------------------

# پاسخ سوالات

سوال 1)

کد تمیز: کد تمیز به کدی گفته می‌شود که ساختار بهینه و قابل‌فهم و آسانی برای نگهداری و توسعه داشته باشد. این نوع کد با استفاده از استانداردها، نام‌گذاری مناسب و ساختارهای خوانا، کاهش پیچیدگی و افزایش قابلیت خواندن را به همراه دارد.

بدهی فنی یا Technical debt: در این مفهوم توسعه دهنده به جای صرف زمان زیاد و یافتن درست‌ترین و بهترین راه‌حل صرفا یک راه‌حل آسان و فوری را برای حل موقت یک مسئله استفاده می‌کند و در عوض متعهد می‌گردد که در آینده زمانی را برای یافتن راه‌حلی اصولی‌تر برای جایگزینی راه‌حل درست صرف نماید. درواقع این مفهوم مشابه مفهوم بهره بانکی است و ممکن است در درازمدت ممکن است به کاهش کارایی و افزایش پیچیدگی ختم شود.

بوی بد: بوی بد به شرایطی در کد گفته می‌شود که در آن سیستم به دلیل ناخوانا بودن کد، نداشتن استانداردهای لازم یا مشکلات برنامه نویسی، عدم بهینگی و شفافیت کد منجر به ایجاد مشکلات بزرگ‌تری در فرایند توسعه خواهد شد. اگر ساختار کد دچار مشکل باشد یا کدهای تکراری زیادی در پروژه رویت شود به اصطلاح به آن بوی بد کد می‌گویند و نشان از این دارد که کد نیازمند اصلاح به جهت افزایش کیفیت و قابلیت نگهداری است.

سوال 2)

Bloaters:

به بخش‌هایی از کد اشاره دارد که بیش از حد بزرگ و پیچیده شده‌اند و امکان ساده‌تر شدن دارند. این اجزا ممکن است شامل تعداد زیادی متغیر یا توابع نامناسب باشد که خوانایی و نگهداری کد را کاهش می‌دهد. مثال بارز آن کلاس‌های طولانی‌ای است که متدها و وظایف زیادی به آنها اختصاص داده شده است.
Dispensables:

به بخش‌هایی از کد اشاره دارد که اضافی و بی‌فایده هستند و درصورت حذفشان تاثیری نخواهند داشت. این اجزا بدون تاثیر مثبت در عملکرد سیستم، فقط ابتلا به پیچیدگی را افزایش می‌دهند و می‌توانند حذف یا بهبود داده شوند. مثال آن کامنتهای میان کد و یا کدهایی است که هرگز استفاده نمی‌شوند (متغیرها و توابعی که فقط تعریف شده اما فراخوانی نمیشوند)

Couplers:

این مورد به اجزایی از کد اشاره دارد که وابستگی‌های زیادی به سایر بخش‌ها دارند. این وابستگی‌ها ممکن است منجر به کاهش انعطاف‌پذیری شود و ایجاد تغییرات را دشوار و کد را آسیب‌پذیر کند. مثلا کلاس‌هایی که وابستگی زیادی به یکدیگر دارند و درصورت بروز هرگونه خطا در یک بخش، بخش دیگر نیز مختل می‌شود.


Object Orientation Abusers:

این مورد به استفاده نادرست یا افراطی از اصول شی‌گرایی می‌پردازد و شامل استفاده نامناسب از ارث‌بری، تعداد زیادی از کلاس‌ها یا ارتباطات پیچیده میان آن‌ها می‌شود که باعث کاهش قابلیت صحت و تغییرات در سیستم می‌شود.


Change Preventers:

اجزایی که مانع اعمال تغییرات در سیستم می‌شوند. این اجزا ممکن است از طریق استفاده از الگوها یا ساختارهای نادرست، وابستگی‌های زیاد و یا انتزاع ضعیف را نتیجه دهند که گسترش و ایجاد تغییرات را مشکل کند.

سوال 3)

این بوی بد به دسته Dispensables تعلق دارد زیرا کلاسی که اطلاعات یا عملکرد کمی دارد و به سادگی می‌تواند درون یک کلاس دیگر جایگزین شود، می‌تواند بدون تاثیر روی عملکرد سیستم به عنوان یک موجودیت قابل حذف در نظر گرفته شود و از پیچیدگی‌های غیرضروری جلوگیری شود. برای برطرف کردن بوی بد، می‌توان از بازآرایی Inline Class یا Collapse Hierarchy استفاده کرد. با این کار، اطلاعات یا عملکرد کلاس تنبل به کلاس دیگر منتقل می‌شود و از وجود یک کلاس تنبل جلوگیری می‌شود. همچنین می‌توان ازMerge Classes نیز استفاده کرد. اگر تعداد زیادی کلاس کوچک با عملکرد بسیار کمی وجود داشته باشند، ادغام آنها به عملکرد پایگاه داده بهبود می‌بخشد. اگر تغییرات زیادی برای انجام وظایف موجود نیست و افزودن یک لایه اضافی پیچیدگی اضافی را به کد نمی‌آورد، می‌توان اجازه داد کلاس تنبل باقی بماند و بوی بد نادیده گرفته شود. اگر اطلاعات یا عملکرد این کلاس در آینده افزایش پیدا کند، ممکن است نیاز به بازآرایی حس شود. همچنین ممکن است کلاس تنبل به منظور دیباگ کردن موردنیاز واقع شود؛ در این مواقع نیز امکان نادیده گرفتن بوی بد جهت توسعه سیستم قابل انجام است.

